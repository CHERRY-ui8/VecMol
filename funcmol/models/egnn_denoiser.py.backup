import torch
import torch.nn as nn
from torch_scatter import scatter
from torch_geometric.nn import MessagePassing, knn_graph, radius_graph
from funcmol.models.encoder import create_grid_coords


class EGNNDenoiserLayer(MessagePassing):
    def __init__(self, in_channels, hidden_channels, out_channels, cutoff=None, radius=None):
        super().__init__(aggr='mean')
        self.in_channels = in_channels
        self.hidden_channels = hidden_channels
        self.out_channels = out_channels
        self.cutoff = cutoff
        self.radius = radius

        # 边特征MLP
        self.edge_mlp = nn.Sequential(
            nn.Linear(2 * in_channels + 1, hidden_channels),
            nn.SiLU(),
            nn.Linear(hidden_channels, hidden_channels),
            nn.SiLU(),
        )
        
        # 节点特征更新MLP
        self.node_mlp = nn.Sequential(
            nn.Linear(in_channels + hidden_channels, hidden_channels),
            nn.SiLU(),
            nn.Linear(hidden_channels, out_channels)
        )
        
        # 添加LayerNorm层
        self.norm = nn.LayerNorm(out_channels)

    def forward(self, x, h, edge_index):
        # LayerNorm + EGNN层
        h = self.norm(h)
        
        # 调试信息：输入变量检查
        if hasattr(self, '_debug_step'):
            self._debug_step += 1
        else:
            self._debug_step = 0
            
        if self._debug_step % 50 == 0:  # 每50步打印一次
            print(f"\n=== EGNNDenoiserLayer Debug (Step {self._debug_step}) ===")
            print(f"Input x: shape={x.shape}, min={x.min().item():.4f}, max={x.max().item():.4f}, mean={x.mean().item():.4f}, std={x.std().item():.4f}")
            print(f"Input h: shape={h.shape}, min={h.min().item():.4f}, max={h.max().item():.4f}, mean={h.mean().item():.4f}, std={h.std().item():.4f}")
            print(f"Edge index: shape={edge_index.shape}, min={edge_index.min().item()}, max={edge_index.max().item()}")
            
            # 详细的边信息检查
            print(f"Number of edges: {edge_index.shape[1]}")
            print(f"Number of nodes: {h.shape[0]}")
            
            # 检查边的连接模式
            unique_sources = torch.unique(edge_index[0]).numel()
            unique_targets = torch.unique(edge_index[1]).numel()
            print(f"Unique source nodes: {unique_sources}, Unique target nodes: {unique_targets}")
            
            # 检查是否有自环
            self_loops = (edge_index[0] == edge_index[1]).sum().item()
            print(f"Self-loops: {self_loops}")
            
            # 检查边的分布
            if edge_index.shape[1] > 0:
                # 统计每个节点的出度和入度
                out_degrees = torch.bincount(edge_index[0], minlength=h.shape[0])
                in_degrees = torch.bincount(edge_index[1], minlength=h.shape[0])
                
                print(f"Out-degree: min={out_degrees.min().item()}, max={out_degrees.max().item()}, mean={out_degrees.float().mean().item():.2f}")
                print(f"In-degree: min={in_degrees.min().item()}, max={in_degrees.max().item()}, mean={in_degrees.float().mean().item():.2f}")
                
                # 检查是否有孤立节点
                isolated_nodes = ((out_degrees == 0) & (in_degrees == 0)).sum().item()
                if isolated_nodes > 0:
                    print(f"⚠️  WARNING: {isolated_nodes} isolated nodes detected!")
                else:
                    print("✅ No isolated nodes")
            
            # 检查坐标范围是否合理
            if x.min().item() < -10 or x.max().item() > 10:
                print("⚠️  WARNING: Coordinates out of expected range [-6, 6]")
            
            # 检查节点特征是否合理
            if h.std().item() > 5 or h.std().item() < 0.1:
                print(f"⚠️  WARNING: Node features std={h.std().item():.4f} seems unusual (expected ~1.0)")
        
        row, col = edge_index
        
        # 安全检查：确保索引在有效范围内
        max_idx = h.size(0)
        if not ((row < max_idx) & (col < max_idx)).all():
            raise ValueError(f"Edge indices out of bounds: max_idx={max_idx}, "
                           f"row_max={row.max().item()}, col_max={col.max().item()}")
        
        # 计算距离和方向 - 使用egnn.py的实现
        rel = x[row] - x[col]  # [E, 3]
        dist = torch.norm(rel, dim=-1, keepdim=True)  # [E, 1]
        
        # 调试信息：距离和相对位置检查
        if self._debug_step % 50 == 0:
            print(f"Relative positions: min={rel.min().item():.4f}, max={rel.max().item():.4f}, mean={rel.mean().item():.4f}, std={rel.std().item():.4f}")
            print(f"Distances: min={dist.min().item():.4f}, max={dist.max().item():.4f}, mean={dist.mean().item():.4f}, std={dist.std().item():.4f}")
            
            # 检查距离是否合理
            if dist.max().item() > 20:
                print("⚠️  WARNING: Very large distances detected, check radius setting")
            if dist.min().item() < 0:
                print("⚠️  ERROR: Negative distances detected!")
        
        # 构造message输入 - NOTE：使用egnn.py的实现
        h_i = h[row]
        h_j = h[col]
        edge_input = torch.cat([h_i, h_j, dist], dim=-1)  # [E, 2*in_channels+1]
        m_ij = self.edge_mlp(edge_input)  # [E, hidden_channels]
        
        # 调试信息：边消息检查
        if self._debug_step % 50 == 0:
            print(f"Edge input: shape={edge_input.shape}, min={edge_input.min().item():.4f}, max={edge_input.max().item():.4f}, mean={edge_input.mean().item():.4f}, std={edge_input.std().item():.4f}")
            print(f"Edge messages m_ij: shape={m_ij.shape}, min={m_ij.min().item():.4f}, max={m_ij.max().item():.4f}, mean={m_ij.mean().item():.4f}, std={m_ij.std().item():.4f}")
            
            # 检查边消息是否合理
            if m_ij.std().item() > 10:
                print("⚠️  WARNING: Edge messages have very high variance, possible gradient explosion")
            if torch.isnan(m_ij).any():
                print("⚠️  ERROR: NaN detected in edge messages!")
            if torch.isinf(m_ij).any():
                print("⚠️  ERROR: Inf detected in edge messages!")
        
        if self.cutoff is not None:
            PI = torch.pi
            C = 0.5 * (torch.cos(dist.squeeze(-1) * PI / self.cutoff) + 1.0)
            C = C * (dist.squeeze(-1) <= self.cutoff) * (dist.squeeze(-1) >= 0.0)
            m_ij = m_ij * C.view(-1, 1)
        
        # 使用 torch_scatter 来聚合边消息到节点
        m_aggr = scatter(m_ij, edge_index[0], dim=0, dim_size=h.size(0), reduce='mean')
        h_delta = self.node_mlp(torch.cat([h, m_aggr], dim=-1))
        h = h + h_delta  # 残差连接
        
        # 调试信息：聚合和输出检查
        if self._debug_step % 50 == 0:
            print(f"Aggregated messages m_aggr: shape={m_aggr.shape}, min={m_aggr.min().item():.4f}, max={m_aggr.max().item():.4f}, mean={m_aggr.mean().item():.4f}, std={m_aggr.std().item():.4f}")
            print(f"Node update h_delta: shape={h_delta.shape}, min={h_delta.min().item():.4f}, max={h_delta.max().item():.4f}, mean={h_delta.mean().item():.4f}, std={h_delta.std().item():.4f}")
            print(f"Output h: shape={h.shape}, min={h.min().item():.4f}, max={h.max().item():.4f}, mean={h.mean().item():.4f}, std={h.std().item():.4f}")
            
            # 检查聚合消息是否合理
            if m_aggr.std().item() > 5:
                print("⚠️  WARNING: Aggregated messages have high variance")
            
            # 检查残差更新是否合理
            residual_ratio = (h_delta.norm() / h.norm()).item()
            if residual_ratio > 1.0:
                print(f"⚠️  WARNING: Large residual update ratio={residual_ratio:.4f} (expected < 1.0)")
            
            # 检查输出是否合理
            if torch.isnan(h).any():
                print("⚠️  ERROR: NaN detected in output!")
            if torch.isinf(h).any():
                print("⚠️  ERROR: Inf detected in output!")
            
            print("=" * 60)
        
        return h

    def message(self, message_j):  
        return message_j


class GNNDenoiser(nn.Module):
    def __init__(self, code_dim=1024, hidden_dim=128, num_layers=4, 
                 cutoff=None, radius=None, dropout=0.1, grid_size=8, 
                 anchor_spacing=2.0, use_radius_graph=True, device=None):
        super().__init__()
        self.code_dim = code_dim
        self.hidden_dim = hidden_dim
        self.num_blocks = num_layers
        self.cutoff = cutoff
        self.radius = radius
        self.grid_size = grid_size
        self.anchor_spacing = anchor_spacing
        self.use_radius_graph = use_radius_graph
        
        if device is None:
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.device = device

        # 输入投影层
        self.input_projection = nn.Linear(code_dim, hidden_dim)
        
        # GNN Layers (now integrated with residual blocks)
        self.blocks = nn.ModuleList([
            EGNNDenoiserLayer(
                in_channels=hidden_dim,
                hidden_channels=hidden_dim,
                out_channels=hidden_dim,
                cutoff=cutoff,
                radius=radius
            ) for _ in range(num_layers)
        ])
        
        # 输出投影层
        self.output_projection = nn.Linear(hidden_dim, code_dim)
        
        # 预创建网格坐标（在__init__中）
        self.register_buffer('grid_coords', 
                           create_grid_coords(
                               batch_size=1, 
                               grid_size=self.grid_size, 
                               device='cpu', 
                               anchor_spacing=self.anchor_spacing
                           ).squeeze(0))  # [n_grid, 3]
        
        self._init_weights()

    def _init_weights(self):
        for module in self.modules():
            if isinstance(module, nn.Linear):
                # 使用更合适的初始化方法
                nn.init.kaiming_normal_(module.weight, mode='fan_in', nonlinearity='relu')
                if module.bias is not None:
                    nn.init.zeros_(module.bias)
            elif isinstance(module, nn.LayerNorm):
                nn.init.ones_(module.weight)
                nn.init.zeros_(module.bias)


    def forward(self, y):
        # 处理输入维度 - 现在只支持3D输入 [batch_size, n_grid, code_dim]
        if y.dim() == 4:  # (batch_size, 1, n_grid, code_dim)
            y = y.squeeze(1)  # (batch_size, n_grid, code_dim)
        elif y.dim() == 3:  # (batch_size, n_grid, code_dim)
            pass
        else:
            raise ValueError(f"Expected 3D or 4D input, got {y.dim()}D: {y.shape}")
        
        batch_size = y.size(0)
        n_grid = y.size(1)
        expected_n_grid = self.grid_size ** 3
        
        # 调试信息：输入检查
        if hasattr(self, '_debug_step'):
            self._debug_step += 1
        else:
            self._debug_step = 0
            
        if False:  # self._debug_step % 100 == 0:  # 每100步打印一次
            print(f"\n=== GNNDenoiser Debug (Step {self._debug_step}) ===")
            print(f"Input y: shape={y.shape}, min={y.min().item():.4f}, max={y.max().item():.4f}, mean={y.mean().item():.4f}, std={y.std().item():.4f}")
            print(f"Batch size: {batch_size}, n_grid: {n_grid}, expected_n_grid: {expected_n_grid}")
            
            # 检查输入是否合理
            if y.std().item() > 5:
                print("⚠️  WARNING: Input codes have high variance")
            if torch.isnan(y).any():
                print("⚠️  ERROR: NaN detected in input!")
            if torch.isinf(y).any():
                print("⚠️  ERROR: Inf detected in input!")
        
        # 构建图 - 直接在这里实现
        # 使用预创建的网格坐标
        n_grid_actual = self.grid_size ** 3
        grid_coords = self.grid_coords.to(self.device)  # [n_grid, 3]
        
        # 为每个batch复制网格坐标
        grid_coords = grid_coords.unsqueeze(0).expand(batch_size, -1, -1)  # [batch_size, n_grid, 3]
        grid_coords = grid_coords.reshape(-1, 3)  # [batch_size * n_grid, 3]
        
        # 创建batch索引
        grid_batch = torch.arange(batch_size, device=self.device).repeat_interleave(n_grid_actual)
        
        # 使用 radius_graph 构建图
        edge_index = radius_graph(
            x=grid_coords,
            r=self.radius,
            batch=grid_batch
        )
        
        # 调试信息：图连接检查
        if False:  # self._debug_step % 100 == 0:
            print(f"\n=== Graph Connection Debug (Step {self._debug_step}) ===")
            print(f"Grid coords shape: {grid_coords.shape}")
            print(f"Grid coords range: min={grid_coords.min().item():.4f}, max={grid_coords.max().item():.4f}")
            print(f"Radius: {self.radius}")
            print(f"Batch info: batch_size={batch_size}, n_grid_per_batch={n_grid_actual}")
            print(f"Total nodes: {grid_coords.shape[0]} (should be {batch_size * n_grid_actual})")
            
            # 检查 edge_index
            print(f"Edge index shape: {edge_index.shape}")
            print(f"Number of edges: {edge_index.shape[1]}")
            print(f"Edge index range: min={edge_index.min().item()}, max={edge_index.max().item()}")
            
            # 检查边的端点是否在有效范围内
            max_node_idx = grid_coords.shape[0] - 1
            invalid_edges = (edge_index < 0) | (edge_index > max_node_idx)
            if invalid_edges.any():
                print(f"⚠️  ERROR: Invalid edge indices detected!")
                print(f"Invalid edges count: {invalid_edges.sum().item()}")
                print(f"Invalid edge indices: {edge_index[invalid_edges]}")
            else:
                print("✅ Edge indices are within valid range")
            
            # 检查每个batch内的连接情况
            for b in range(batch_size):
                batch_start = b * n_grid_actual
                batch_end = (b + 1) * n_grid_actual
                batch_edges = (edge_index[0] >= batch_start) & (edge_index[0] < batch_end)
                batch_edge_count = batch_edges.sum().item()
                print(f"Batch {b}: {batch_edge_count} edges (nodes {batch_start}-{batch_end-1})")
                
                if batch_edge_count == 0:
                    print(f"⚠️  WARNING: Batch {b} has no edges!")
                elif batch_edge_count < n_grid_actual * 0.1:  # 少于10%的节点有连接
                    print(f"⚠️  WARNING: Batch {b} has very few edges ({batch_edge_count})")
            
            # 检查边的距离分布
            if edge_index.shape[1] > 0:
                edge_distances = []
                for i in range(min(1000, edge_index.shape[1])):  # 只检查前1000条边
                    src_idx = edge_index[0, i].item()
                    dst_idx = edge_index[1, i].item()
                    if src_idx < grid_coords.shape[0] and dst_idx < grid_coords.shape[0]:
                        dist = torch.norm(grid_coords[src_idx] - grid_coords[dst_idx]).item()
                        edge_distances.append(dist)
                
                if edge_distances:
                    edge_distances = torch.tensor(edge_distances)
                    print(f"Edge distances: min={edge_distances.min().item():.4f}, max={edge_distances.max().item():.4f}, mean={edge_distances.mean().item():.4f}")
                    
                    # 检查是否有超出半径的边
                    edges_outside_radius = (edge_distances > self.radius).sum().item()
                    if edges_outside_radius > 0:
                        print(f"⚠️  WARNING: {edges_outside_radius} edges have distance > radius ({self.radius})")
                    else:
                        print("✅ All edges are within radius")
            
            print("=" * 60)
        
        # 输入投影
        h = self.input_projection(y)  # (batch_size, n_grid, hidden_dim)
        h = h.reshape(-1, self.hidden_dim)  # (batch_size * n_grid, hidden_dim)
        
        # 通过GNN块
        for block in self.blocks:
            h = block(grid_coords, h, edge_index)
        
        # 重塑回原始维度
        h = h.view(batch_size, n_grid, self.hidden_dim)
        
        # 输出投影
        output = self.output_projection(h)
        
        # 调试信息：输出检查
        if False:  # self._debug_step % 100 == 0:
            print(f"Final output: shape={output.shape}, min={output.min().item():.4f}, max={output.max().item():.4f}, mean={output.mean().item():.4f}, std={output.std().item():.4f}")
            
            # 检查输出是否合理
            if output.std().item() > 10:
                print("⚠️  WARNING: Output has very high variance")
            if torch.isnan(output).any():
                print("⚠️  ERROR: NaN detected in output!")
            if torch.isinf(output).any():
                print("⚠️  ERROR: Inf detected in output!")
            
            # 检查输入输出差异
            input_output_diff = (output - y).norm().item()
            print(f"Input-output difference norm: {input_output_diff:.4f}")
            if input_output_diff < 0.01:
                print("⚠️  WARNING: Very small input-output difference, model might not be learning")
            
            print("=" * 60)
        
        return output
