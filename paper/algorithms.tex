\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\title{FuncMol Algorithm Pseudocode}

\author{Yuchen Hua}

\date{November 2025}

\begin{document}

\maketitle

\IncMargin{1em}

% ============================================
% Algorithm 1: Neural Field Autoencoder Training
% ============================================

\begin{algorithm}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}

\Input{Molecular dataset $\mathcal{D}$ with atom coordinates and types}
\Output{Trained encoder $E_\phi$ and decoder $D_\psi$}

\BlankLine

Initialize encoder $E_\phi$ and decoder $D_\psi$\;
Create anchor grid $\mathcal{G}$\;

\BlankLine

\For{epoch $\leftarrow$ 1 \KwTo max\_epochs}{
    \For{molecule $(X, T)$ in $\mathcal{D}$}{
        Encode molecule to latent code: latent\_code $\leftarrow E_\phi(X, T)$\;
        Sample query points: query\_points $\leftarrow$ sample\_from\_grid(grid)\;
        Decode to vector field: predicted\_field $\leftarrow D_\psi($query\_points, latent\_code$)$\;
        Compute ground truth field: gt\_field $\leftarrow$ GNFConverter$(X, T, $query\_points$)$\;
        Compute loss: loss $\leftarrow$ MSE$(predicted\_field, gt\_field)$\;
        Backpropagate and update parameters\;
    }
}

\Return{$E_\phi$, $D_\psi$}

\caption{Neural Field Autoencoder Training}
\label{algo_autoencoder}
\end{algorithm}

% ============================================
% Algorithm 2: DDPM Training
% ============================================

\begin{algorithm}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}

\Input{Pre-trained encoder $E_\phi$, latent code dataset $\mathcal{Z}$}
\Output{Trained denoiser $f_\theta$}

\BlankLine

Initialize denoiser $f_\theta$\;
Define noise schedule $\{\beta_t\}_{t=1}^T$\;

\BlankLine

\For{epoch $\leftarrow$ 1 \KwTo max\_epochs}{
    \For{latent\_code $z$ in $\mathcal{Z}$}{
        Sample time step: $t \leftarrow$ uniform$(1, \ldots, T)$\;
        Sample noise: noise $\leftarrow$ Gaussian$(0, I)$\;
        Add noise: noisy\_code $\leftarrow$ add\_noise$(z, $noise$, t)$\;
        Denoise: predicted $\leftarrow f_\theta($noisy\_code$, t)$\;
        \eIf{prediction method == "predict\_epsilon"}{
            loss $\leftarrow$ MSE$(noise, predicted)$\;
        }{
            loss $\leftarrow$ MSE$(z, predicted)$\;
        }
        Backpropagate and update parameters\;
    }
}

\Return{$f_\theta$}

\caption{DDPM Training (FuncMol Denoiser)}
\label{algo_ddpm_train}
\end{algorithm}

% ============================================
% Algorithm 3: DDPM Sampling
% ============================================

\begin{algorithm}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}

\Input{Trained denoiser $f_\theta$, decoder $D_\psi$}
\Output{Generated molecular structure $(X_{gen}, T_{gen})$}

\BlankLine

Initialize: $z_T \leftarrow$ Gaussian$(0, I)$\;

\BlankLine

\For{$t \leftarrow T$ \KwDownTo $1$}{
    \eIf{prediction method == "predict\_epsilon"}{
        predicted\_noise $\leftarrow f_\theta(z_t, t)$\;
        predicted\_clean $\leftarrow$ compute\_from\_noise$(z_t, $predicted\_noise$, t)$\;
    }{
        predicted\_clean $\leftarrow f_\theta(z_t, t)$\;
    }
    Compute mean and variance for $z_{t-1}$\;
    \eIf{$t > 1$}{
        $z_{t-1} \leftarrow$ sample$(mean, variance)$\;
    }{
        $z_0 \leftarrow mean$\;
    }
}

Sample query points: query\_points $\leftarrow$ uniform\_sample(bounding\_box)\;
Decode to vector field: vector\_field $\leftarrow D_\psi($query\_points$, z_0)$\;
Reconstruct molecule: $(X_{gen}, T_{gen}) \leftarrow$ FieldToMolecule$(vector\_field, $query\_points$)$\;

\Return{$(X_{gen}, T_{gen})$}

\caption{DDPM Sampling}
\label{algo_ddpm_sample}
\end{algorithm}

\DecMargin{1em}

\end{document}
